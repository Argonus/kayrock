defmodule(Kayrock.Fetch) do
  @moduledoc false
  _ = " THIS CODE IS GENERATED BY KAYROCK"

  defmodule(V0.Request) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      replica_id: nil,
      max_wait_time: nil,
      min_bytes: nil,
      topics: [],
      correlation_id: nil,
      client_id: nil
    )

    import(Elixir.Kayrock.Serialize)
    @type t :: %__MODULE__{}
    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      0
    end

    def(response_deserializer) do
      &V0.Response.deserialize/1
    end

    def(schema) do
      [
        replica_id: :int32,
        max_wait_time: :int32,
        min_bytes: :int32,
        topics:
          {:array,
           [
             topic: :string,
             partitions: {:array, [partition: :int32, fetch_offset: :int64, max_bytes: :int32]}
           ]}
      ]
    end

    def(serialize(%V0.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id()::32,
          byte_size(struct.client_id())::16, struct.client_id()::binary>>,
        [
          serialize(:int32, Map.get(struct, :replica_id)),
          serialize(:int32, Map.get(struct, :max_wait_time)),
          serialize(:int32, Map.get(struct, :min_bytes)),
          case(Map.get(struct, :topics)) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for(v <- vals) do
                  [
                    serialize(:string, Map.get(v, :topic)),
                    case(Map.get(v, :partitions)) do
                      nil ->
                        <<-1::32-signed>>

                      [] ->
                        <<0::32-signed>>

                      vals when is_list(vals) ->
                        [
                          <<length(vals)::32-signed>>,
                          for(v <- vals) do
                            [
                              serialize(:int32, Map.get(v, :partition)),
                              serialize(:int64, Map.get(v, :fetch_offset)),
                              serialize(:int32, Map.get(v, :max_bytes))
                            ]
                          end
                        ]
                    end
                  ]
                end
              ]
          end
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V0.Request) do
    def(serialize(%V0.Request{} = struct)) do
      V0.Request.serialize(struct)
    end

    def(api_vsn(%V0.Request{})) do
      V0.Request.api_vsn()
    end

    def(response_deserializer(%V0.Request{})) do
      V0.Request.response_deserializer()
    end
  end

  defmodule(V1.Request) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      replica_id: nil,
      max_wait_time: nil,
      min_bytes: nil,
      topics: [],
      correlation_id: nil,
      client_id: nil
    )

    import(Elixir.Kayrock.Serialize)
    @type t :: %__MODULE__{}
    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      1
    end

    def(response_deserializer) do
      &V1.Response.deserialize/1
    end

    def(schema) do
      [
        replica_id: :int32,
        max_wait_time: :int32,
        min_bytes: :int32,
        topics:
          {:array,
           [
             topic: :string,
             partitions: {:array, [partition: :int32, fetch_offset: :int64, max_bytes: :int32]}
           ]}
      ]
    end

    def(serialize(%V1.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id()::32,
          byte_size(struct.client_id())::16, struct.client_id()::binary>>,
        [
          serialize(:int32, Map.get(struct, :replica_id)),
          serialize(:int32, Map.get(struct, :max_wait_time)),
          serialize(:int32, Map.get(struct, :min_bytes)),
          case(Map.get(struct, :topics)) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for(v <- vals) do
                  [
                    serialize(:string, Map.get(v, :topic)),
                    case(Map.get(v, :partitions)) do
                      nil ->
                        <<-1::32-signed>>

                      [] ->
                        <<0::32-signed>>

                      vals when is_list(vals) ->
                        [
                          <<length(vals)::32-signed>>,
                          for(v <- vals) do
                            [
                              serialize(:int32, Map.get(v, :partition)),
                              serialize(:int64, Map.get(v, :fetch_offset)),
                              serialize(:int32, Map.get(v, :max_bytes))
                            ]
                          end
                        ]
                    end
                  ]
                end
              ]
          end
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V1.Request) do
    def(serialize(%V1.Request{} = struct)) do
      V1.Request.serialize(struct)
    end

    def(api_vsn(%V1.Request{})) do
      V1.Request.api_vsn()
    end

    def(response_deserializer(%V1.Request{})) do
      V1.Request.response_deserializer()
    end
  end

  defmodule(V2.Request) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      replica_id: nil,
      max_wait_time: nil,
      min_bytes: nil,
      topics: [],
      correlation_id: nil,
      client_id: nil
    )

    import(Elixir.Kayrock.Serialize)
    @type t :: %__MODULE__{}
    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      2
    end

    def(response_deserializer) do
      &V2.Response.deserialize/1
    end

    def(schema) do
      [
        replica_id: :int32,
        max_wait_time: :int32,
        min_bytes: :int32,
        topics:
          {:array,
           [
             topic: :string,
             partitions: {:array, [partition: :int32, fetch_offset: :int64, max_bytes: :int32]}
           ]}
      ]
    end

    def(serialize(%V2.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id()::32,
          byte_size(struct.client_id())::16, struct.client_id()::binary>>,
        [
          serialize(:int32, Map.get(struct, :replica_id)),
          serialize(:int32, Map.get(struct, :max_wait_time)),
          serialize(:int32, Map.get(struct, :min_bytes)),
          case(Map.get(struct, :topics)) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for(v <- vals) do
                  [
                    serialize(:string, Map.get(v, :topic)),
                    case(Map.get(v, :partitions)) do
                      nil ->
                        <<-1::32-signed>>

                      [] ->
                        <<0::32-signed>>

                      vals when is_list(vals) ->
                        [
                          <<length(vals)::32-signed>>,
                          for(v <- vals) do
                            [
                              serialize(:int32, Map.get(v, :partition)),
                              serialize(:int64, Map.get(v, :fetch_offset)),
                              serialize(:int32, Map.get(v, :max_bytes))
                            ]
                          end
                        ]
                    end
                  ]
                end
              ]
          end
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V2.Request) do
    def(serialize(%V2.Request{} = struct)) do
      V2.Request.serialize(struct)
    end

    def(api_vsn(%V2.Request{})) do
      V2.Request.api_vsn()
    end

    def(response_deserializer(%V2.Request{})) do
      V2.Request.response_deserializer()
    end
  end

  defmodule(V3.Request) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      replica_id: nil,
      max_wait_time: nil,
      min_bytes: nil,
      max_bytes: nil,
      topics: [],
      correlation_id: nil,
      client_id: nil
    )

    import(Elixir.Kayrock.Serialize)
    @type t :: %__MODULE__{}
    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      3
    end

    def(response_deserializer) do
      &V3.Response.deserialize/1
    end

    def(schema) do
      [
        replica_id: :int32,
        max_wait_time: :int32,
        min_bytes: :int32,
        max_bytes: :int32,
        topics:
          {:array,
           [
             topic: :string,
             partitions: {:array, [partition: :int32, fetch_offset: :int64, max_bytes: :int32]}
           ]}
      ]
    end

    def(serialize(%V3.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id()::32,
          byte_size(struct.client_id())::16, struct.client_id()::binary>>,
        [
          serialize(:int32, Map.get(struct, :replica_id)),
          serialize(:int32, Map.get(struct, :max_wait_time)),
          serialize(:int32, Map.get(struct, :min_bytes)),
          serialize(:int32, Map.get(struct, :max_bytes)),
          case(Map.get(struct, :topics)) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for(v <- vals) do
                  [
                    serialize(:string, Map.get(v, :topic)),
                    case(Map.get(v, :partitions)) do
                      nil ->
                        <<-1::32-signed>>

                      [] ->
                        <<0::32-signed>>

                      vals when is_list(vals) ->
                        [
                          <<length(vals)::32-signed>>,
                          for(v <- vals) do
                            [
                              serialize(:int32, Map.get(v, :partition)),
                              serialize(:int64, Map.get(v, :fetch_offset)),
                              serialize(:int32, Map.get(v, :max_bytes))
                            ]
                          end
                        ]
                    end
                  ]
                end
              ]
          end
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V3.Request) do
    def(serialize(%V3.Request{} = struct)) do
      V3.Request.serialize(struct)
    end

    def(api_vsn(%V3.Request{})) do
      V3.Request.api_vsn()
    end

    def(response_deserializer(%V3.Request{})) do
      V3.Request.response_deserializer()
    end
  end

  defmodule(V4.Request) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      replica_id: nil,
      max_wait_time: nil,
      min_bytes: nil,
      max_bytes: nil,
      isolation_level: nil,
      topics: [],
      correlation_id: nil,
      client_id: nil
    )

    import(Elixir.Kayrock.Serialize)
    @type t :: %__MODULE__{}
    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      4
    end

    def(response_deserializer) do
      &V4.Response.deserialize/1
    end

    def(schema) do
      [
        replica_id: :int32,
        max_wait_time: :int32,
        min_bytes: :int32,
        max_bytes: :int32,
        isolation_level: :int8,
        topics:
          {:array,
           [
             topic: :string,
             partitions: {:array, [partition: :int32, fetch_offset: :int64, max_bytes: :int32]}
           ]}
      ]
    end

    def(serialize(%V4.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id()::32,
          byte_size(struct.client_id())::16, struct.client_id()::binary>>,
        [
          serialize(:int32, Map.get(struct, :replica_id)),
          serialize(:int32, Map.get(struct, :max_wait_time)),
          serialize(:int32, Map.get(struct, :min_bytes)),
          serialize(:int32, Map.get(struct, :max_bytes)),
          serialize(:int8, Map.get(struct, :isolation_level)),
          case(Map.get(struct, :topics)) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for(v <- vals) do
                  [
                    serialize(:string, Map.get(v, :topic)),
                    case(Map.get(v, :partitions)) do
                      nil ->
                        <<-1::32-signed>>

                      [] ->
                        <<0::32-signed>>

                      vals when is_list(vals) ->
                        [
                          <<length(vals)::32-signed>>,
                          for(v <- vals) do
                            [
                              serialize(:int32, Map.get(v, :partition)),
                              serialize(:int64, Map.get(v, :fetch_offset)),
                              serialize(:int32, Map.get(v, :max_bytes))
                            ]
                          end
                        ]
                    end
                  ]
                end
              ]
          end
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V4.Request) do
    def(serialize(%V4.Request{} = struct)) do
      V4.Request.serialize(struct)
    end

    def(api_vsn(%V4.Request{})) do
      V4.Request.api_vsn()
    end

    def(response_deserializer(%V4.Request{})) do
      V4.Request.response_deserializer()
    end
  end

  defmodule(V5.Request) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      replica_id: nil,
      max_wait_time: nil,
      min_bytes: nil,
      max_bytes: nil,
      isolation_level: nil,
      topics: [],
      correlation_id: nil,
      client_id: nil
    )

    import(Elixir.Kayrock.Serialize)
    @type t :: %__MODULE__{}
    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      5
    end

    def(response_deserializer) do
      &V5.Response.deserialize/1
    end

    def(schema) do
      [
        replica_id: :int32,
        max_wait_time: :int32,
        min_bytes: :int32,
        max_bytes: :int32,
        isolation_level: :int8,
        topics:
          {:array,
           [
             topic: :string,
             partitions:
               {:array,
                [
                  partition: :int32,
                  fetch_offset: :int64,
                  log_start_offset: :int64,
                  max_bytes: :int32
                ]}
           ]}
      ]
    end

    def(serialize(%V5.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id()::32,
          byte_size(struct.client_id())::16, struct.client_id()::binary>>,
        [
          serialize(:int32, Map.get(struct, :replica_id)),
          serialize(:int32, Map.get(struct, :max_wait_time)),
          serialize(:int32, Map.get(struct, :min_bytes)),
          serialize(:int32, Map.get(struct, :max_bytes)),
          serialize(:int8, Map.get(struct, :isolation_level)),
          case(Map.get(struct, :topics)) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for(v <- vals) do
                  [
                    serialize(:string, Map.get(v, :topic)),
                    case(Map.get(v, :partitions)) do
                      nil ->
                        <<-1::32-signed>>

                      [] ->
                        <<0::32-signed>>

                      vals when is_list(vals) ->
                        [
                          <<length(vals)::32-signed>>,
                          for(v <- vals) do
                            [
                              serialize(:int32, Map.get(v, :partition)),
                              serialize(:int64, Map.get(v, :fetch_offset)),
                              serialize(:int64, Map.get(v, :log_start_offset)),
                              serialize(:int32, Map.get(v, :max_bytes))
                            ]
                          end
                        ]
                    end
                  ]
                end
              ]
          end
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V5.Request) do
    def(serialize(%V5.Request{} = struct)) do
      V5.Request.serialize(struct)
    end

    def(api_vsn(%V5.Request{})) do
      V5.Request.api_vsn()
    end

    def(response_deserializer(%V5.Request{})) do
      V5.Request.response_deserializer()
    end
  end

  defmodule(V6.Request) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      replica_id: nil,
      max_wait_time: nil,
      min_bytes: nil,
      max_bytes: nil,
      isolation_level: nil,
      topics: [],
      correlation_id: nil,
      client_id: nil
    )

    import(Elixir.Kayrock.Serialize)
    @type t :: %__MODULE__{}
    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      6
    end

    def(response_deserializer) do
      &V6.Response.deserialize/1
    end

    def(schema) do
      [
        replica_id: :int32,
        max_wait_time: :int32,
        min_bytes: :int32,
        max_bytes: :int32,
        isolation_level: :int8,
        topics:
          {:array,
           [
             topic: :string,
             partitions:
               {:array,
                [
                  partition: :int32,
                  fetch_offset: :int64,
                  log_start_offset: :int64,
                  max_bytes: :int32
                ]}
           ]}
      ]
    end

    def(serialize(%V6.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id()::32,
          byte_size(struct.client_id())::16, struct.client_id()::binary>>,
        [
          serialize(:int32, Map.get(struct, :replica_id)),
          serialize(:int32, Map.get(struct, :max_wait_time)),
          serialize(:int32, Map.get(struct, :min_bytes)),
          serialize(:int32, Map.get(struct, :max_bytes)),
          serialize(:int8, Map.get(struct, :isolation_level)),
          case(Map.get(struct, :topics)) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for(v <- vals) do
                  [
                    serialize(:string, Map.get(v, :topic)),
                    case(Map.get(v, :partitions)) do
                      nil ->
                        <<-1::32-signed>>

                      [] ->
                        <<0::32-signed>>

                      vals when is_list(vals) ->
                        [
                          <<length(vals)::32-signed>>,
                          for(v <- vals) do
                            [
                              serialize(:int32, Map.get(v, :partition)),
                              serialize(:int64, Map.get(v, :fetch_offset)),
                              serialize(:int64, Map.get(v, :log_start_offset)),
                              serialize(:int32, Map.get(v, :max_bytes))
                            ]
                          end
                        ]
                    end
                  ]
                end
              ]
          end
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V6.Request) do
    def(serialize(%V6.Request{} = struct)) do
      V6.Request.serialize(struct)
    end

    def(api_vsn(%V6.Request{})) do
      V6.Request.api_vsn()
    end

    def(response_deserializer(%V6.Request{})) do
      V6.Request.response_deserializer()
    end
  end

  defmodule(V7.Request) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      replica_id: nil,
      max_wait_time: nil,
      min_bytes: nil,
      max_bytes: nil,
      isolation_level: nil,
      session_id: nil,
      epoch: nil,
      topics: [],
      forgetten_topics_data: [],
      correlation_id: nil,
      client_id: nil
    )

    import(Elixir.Kayrock.Serialize)
    @type t :: %__MODULE__{}
    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      7
    end

    def(response_deserializer) do
      &V7.Response.deserialize/1
    end

    def(schema) do
      [
        replica_id: :int32,
        max_wait_time: :int32,
        min_bytes: :int32,
        max_bytes: :int32,
        isolation_level: :int8,
        session_id: :int32,
        epoch: :int32,
        topics:
          {:array,
           [
             topic: :string,
             partitions:
               {:array,
                [
                  partition: :int32,
                  fetch_offset: :int64,
                  log_start_offset: :int64,
                  max_bytes: :int32
                ]}
           ]},
        forgetten_topics_data:
          {:array,
           [
             topic: :string,
             partitions:
               {:array,
                [
                  partition: :int32,
                  fetch_offset: :int64,
                  log_start_offset: :int64,
                  max_bytes: :int32
                ]}
           ]}
      ]
    end

    def(serialize(%V7.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id()::32,
          byte_size(struct.client_id())::16, struct.client_id()::binary>>,
        [
          serialize(:int32, Map.get(struct, :replica_id)),
          serialize(:int32, Map.get(struct, :max_wait_time)),
          serialize(:int32, Map.get(struct, :min_bytes)),
          serialize(:int32, Map.get(struct, :max_bytes)),
          serialize(:int8, Map.get(struct, :isolation_level)),
          serialize(:int32, Map.get(struct, :session_id)),
          serialize(:int32, Map.get(struct, :epoch)),
          case(Map.get(struct, :topics)) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for(v <- vals) do
                  [
                    serialize(:string, Map.get(v, :topic)),
                    case(Map.get(v, :partitions)) do
                      nil ->
                        <<-1::32-signed>>

                      [] ->
                        <<0::32-signed>>

                      vals when is_list(vals) ->
                        [
                          <<length(vals)::32-signed>>,
                          for(v <- vals) do
                            [
                              serialize(:int32, Map.get(v, :partition)),
                              serialize(:int64, Map.get(v, :fetch_offset)),
                              serialize(:int64, Map.get(v, :log_start_offset)),
                              serialize(:int32, Map.get(v, :max_bytes))
                            ]
                          end
                        ]
                    end
                  ]
                end
              ]
          end,
          case(Map.get(struct, :forgetten_topics_data)) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for(v <- vals) do
                  [
                    serialize(:string, Map.get(v, :topic)),
                    case(Map.get(v, :partitions)) do
                      nil ->
                        <<-1::32-signed>>

                      [] ->
                        <<0::32-signed>>

                      vals when is_list(vals) ->
                        [
                          <<length(vals)::32-signed>>,
                          for(v <- vals) do
                            [
                              serialize(:int32, Map.get(v, :partition)),
                              serialize(:int64, Map.get(v, :fetch_offset)),
                              serialize(:int64, Map.get(v, :log_start_offset)),
                              serialize(:int32, Map.get(v, :max_bytes))
                            ]
                          end
                        ]
                    end
                  ]
                end
              ]
          end
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V7.Request) do
    def(serialize(%V7.Request{} = struct)) do
      V7.Request.serialize(struct)
    end

    def(api_vsn(%V7.Request{})) do
      V7.Request.api_vsn()
    end

    def(response_deserializer(%V7.Request{})) do
      V7.Request.response_deserializer()
    end
  end

  def(get_request_struct(0)) do
    %V0.Request{}
  end

  def(get_request_struct(1)) do
    %V1.Request{}
  end

  def(get_request_struct(2)) do
    %V2.Request{}
  end

  def(get_request_struct(3)) do
    %V3.Request{}
  end

  def(get_request_struct(4)) do
    %V4.Request{}
  end

  def(get_request_struct(5)) do
    %V5.Request{}
  end

  def(get_request_struct(6)) do
    %V6.Request{}
  end

  def(get_request_struct(7)) do
    %V7.Request{}
  end

  defmodule(V0.Response) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(responses: [], correlation_id: nil)
    @type t :: %__MODULE__{}
    import(Elixir.Kayrock.Deserialize)

    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      0
    end

    def(schema) do
      [
        responses:
          {:array,
           [
             topic: :string,
             partition_responses:
               {:array,
                [
                  partition_header: [
                    partition: :int32,
                    error_code: :int16,
                    high_watermark: :int64
                  ],
                  record_set: :records
                ]}
           ]}
      ]
    end

    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data
      deserialize_field(:root, :responses, %__MODULE__{correlation_id: correlation_id}, rest)
    end

    defp(deserialize_field(:responses, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:responses, :partition_responses, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:partition_header, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_header, :error_code, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_header, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_header, :high_watermark, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_header, :high_watermark, acc, data)) do
      {val, rest} = deserialize(:int64, data)
      deserialize_field(:partition_header, nil, Map.put(acc, :high_watermark, val), rest)
    end

    defp(deserialize_field(:partition_responses, :partition_header, acc, data)) do
      {val, rest} = deserialize_field(:partition_header, :partition, %{}, data)

      deserialize_field(
        :partition_responses,
        :record_set,
        Map.put(acc, :partition_header, val),
        rest
      )
    end

    defp(deserialize_field(:partition_responses, :record_set, acc, data)) do
      <<msg_set_size::32-signed, msg_set_data::size(msg_set_size)-binary, rest::bits>> = data
      val = Elixir.Kayrock.RecordBatch.deserialize(msg_set_size, msg_set_data)
      deserialize_field(:partition_responses, nil, Map.put(acc, :record_set, val), rest)
    end

    defp(deserialize_field(:responses, :partition_responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_responses, :partition_header, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :responses,
        nil,
        Map.put(acc, :partition_responses, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:responses, :topic, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :responses, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  defmodule(V1.Response) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(throttle_time_ms: nil, responses: [], correlation_id: nil)
    @type t :: %__MODULE__{}
    import(Elixir.Kayrock.Deserialize)

    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      1
    end

    def(schema) do
      [
        throttle_time_ms: :int32,
        responses:
          {:array,
           [
             topic: :string,
             partition_responses:
               {:array,
                [
                  partition_header: [
                    partition: :int32,
                    error_code: :int16,
                    high_watermark: :int64
                  ],
                  record_set: :records
                ]}
           ]}
      ]
    end

    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp(deserialize_field(:root, :throttle_time_ms, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :responses, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp(deserialize_field(:responses, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:responses, :partition_responses, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:partition_header, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_header, :error_code, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_header, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_header, :high_watermark, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_header, :high_watermark, acc, data)) do
      {val, rest} = deserialize(:int64, data)
      deserialize_field(:partition_header, nil, Map.put(acc, :high_watermark, val), rest)
    end

    defp(deserialize_field(:partition_responses, :partition_header, acc, data)) do
      {val, rest} = deserialize_field(:partition_header, :partition, %{}, data)

      deserialize_field(
        :partition_responses,
        :record_set,
        Map.put(acc, :partition_header, val),
        rest
      )
    end

    defp(deserialize_field(:partition_responses, :record_set, acc, data)) do
      <<msg_set_size::32-signed, msg_set_data::size(msg_set_size)-binary, rest::bits>> = data
      val = Elixir.Kayrock.RecordBatch.deserialize(msg_set_size, msg_set_data)
      deserialize_field(:partition_responses, nil, Map.put(acc, :record_set, val), rest)
    end

    defp(deserialize_field(:responses, :partition_responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_responses, :partition_header, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :responses,
        nil,
        Map.put(acc, :partition_responses, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:responses, :topic, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :responses, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  defmodule(V2.Response) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(throttle_time_ms: nil, responses: [], correlation_id: nil)
    @type t :: %__MODULE__{}
    import(Elixir.Kayrock.Deserialize)

    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      2
    end

    def(schema) do
      [
        throttle_time_ms: :int32,
        responses:
          {:array,
           [
             topic: :string,
             partition_responses:
               {:array,
                [
                  partition_header: [
                    partition: :int32,
                    error_code: :int16,
                    high_watermark: :int64
                  ],
                  record_set: :records
                ]}
           ]}
      ]
    end

    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp(deserialize_field(:root, :throttle_time_ms, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :responses, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp(deserialize_field(:responses, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:responses, :partition_responses, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:partition_header, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_header, :error_code, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_header, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_header, :high_watermark, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_header, :high_watermark, acc, data)) do
      {val, rest} = deserialize(:int64, data)
      deserialize_field(:partition_header, nil, Map.put(acc, :high_watermark, val), rest)
    end

    defp(deserialize_field(:partition_responses, :partition_header, acc, data)) do
      {val, rest} = deserialize_field(:partition_header, :partition, %{}, data)

      deserialize_field(
        :partition_responses,
        :record_set,
        Map.put(acc, :partition_header, val),
        rest
      )
    end

    defp(deserialize_field(:partition_responses, :record_set, acc, data)) do
      <<msg_set_size::32-signed, msg_set_data::size(msg_set_size)-binary, rest::bits>> = data
      val = Elixir.Kayrock.RecordBatch.deserialize(msg_set_size, msg_set_data)
      deserialize_field(:partition_responses, nil, Map.put(acc, :record_set, val), rest)
    end

    defp(deserialize_field(:responses, :partition_responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_responses, :partition_header, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :responses,
        nil,
        Map.put(acc, :partition_responses, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:responses, :topic, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :responses, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  defmodule(V3.Response) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(throttle_time_ms: nil, responses: [], correlation_id: nil)
    @type t :: %__MODULE__{}
    import(Elixir.Kayrock.Deserialize)

    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      3
    end

    def(schema) do
      [
        throttle_time_ms: :int32,
        responses:
          {:array,
           [
             topic: :string,
             partition_responses:
               {:array,
                [
                  partition_header: [
                    partition: :int32,
                    error_code: :int16,
                    high_watermark: :int64
                  ],
                  record_set: :records
                ]}
           ]}
      ]
    end

    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp(deserialize_field(:root, :throttle_time_ms, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :responses, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp(deserialize_field(:responses, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:responses, :partition_responses, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:partition_header, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_header, :error_code, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_header, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_header, :high_watermark, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_header, :high_watermark, acc, data)) do
      {val, rest} = deserialize(:int64, data)
      deserialize_field(:partition_header, nil, Map.put(acc, :high_watermark, val), rest)
    end

    defp(deserialize_field(:partition_responses, :partition_header, acc, data)) do
      {val, rest} = deserialize_field(:partition_header, :partition, %{}, data)

      deserialize_field(
        :partition_responses,
        :record_set,
        Map.put(acc, :partition_header, val),
        rest
      )
    end

    defp(deserialize_field(:partition_responses, :record_set, acc, data)) do
      <<msg_set_size::32-signed, msg_set_data::size(msg_set_size)-binary, rest::bits>> = data
      val = Elixir.Kayrock.RecordBatch.deserialize(msg_set_size, msg_set_data)
      deserialize_field(:partition_responses, nil, Map.put(acc, :record_set, val), rest)
    end

    defp(deserialize_field(:responses, :partition_responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_responses, :partition_header, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :responses,
        nil,
        Map.put(acc, :partition_responses, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:responses, :topic, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :responses, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  defmodule(V4.Response) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(throttle_time_ms: nil, responses: [], correlation_id: nil)
    @type t :: %__MODULE__{}
    import(Elixir.Kayrock.Deserialize)

    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      4
    end

    def(schema) do
      [
        throttle_time_ms: :int32,
        responses:
          {:array,
           [
             topic: :string,
             partition_responses:
               {:array,
                [
                  partition_header: [
                    partition: :int32,
                    error_code: :int16,
                    high_watermark: :int64,
                    last_stable_offset: :int64,
                    aborted_transactions: {:array, [producer_id: :int64, first_offset: :int64]}
                  ],
                  record_set: :records
                ]}
           ]}
      ]
    end

    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp(deserialize_field(:root, :throttle_time_ms, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :responses, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp(deserialize_field(:responses, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:responses, :partition_responses, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:partition_header, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_header, :error_code, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_header, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_header, :high_watermark, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_header, :high_watermark, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :partition_header,
        :last_stable_offset,
        Map.put(acc, :high_watermark, val),
        rest
      )
    end

    defp(deserialize_field(:partition_header, :last_stable_offset, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :partition_header,
        :aborted_transactions,
        Map.put(acc, :last_stable_offset, val),
        rest
      )
    end

    defp(deserialize_field(:aborted_transactions, :producer_id, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :aborted_transactions,
        :first_offset,
        Map.put(acc, :producer_id, val),
        rest
      )
    end

    defp(deserialize_field(:aborted_transactions, :first_offset, acc, data)) do
      {val, rest} = deserialize(:int64, data)
      deserialize_field(:aborted_transactions, nil, Map.put(acc, :first_offset, val), rest)
    end

    defp(deserialize_field(:partition_header, :aborted_transactions, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:aborted_transactions, :producer_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :partition_header,
        nil,
        Map.put(acc, :aborted_transactions, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:partition_responses, :partition_header, acc, data)) do
      {val, rest} = deserialize_field(:partition_header, :partition, %{}, data)

      deserialize_field(
        :partition_responses,
        :record_set,
        Map.put(acc, :partition_header, val),
        rest
      )
    end

    defp(deserialize_field(:partition_responses, :record_set, acc, data)) do
      <<msg_set_size::32-signed, msg_set_data::size(msg_set_size)-binary, rest::bits>> = data
      val = Elixir.Kayrock.RecordBatch.deserialize(msg_set_size, msg_set_data)
      deserialize_field(:partition_responses, nil, Map.put(acc, :record_set, val), rest)
    end

    defp(deserialize_field(:responses, :partition_responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_responses, :partition_header, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :responses,
        nil,
        Map.put(acc, :partition_responses, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:responses, :topic, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :responses, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  defmodule(V5.Response) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(throttle_time_ms: nil, responses: [], correlation_id: nil)
    @type t :: %__MODULE__{}
    import(Elixir.Kayrock.Deserialize)

    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      5
    end

    def(schema) do
      [
        throttle_time_ms: :int32,
        responses:
          {:array,
           [
             topic: :string,
             partition_responses:
               {:array,
                [
                  partition_header: [
                    partition: :int32,
                    error_code: :int16,
                    high_watermark: :int64,
                    last_stable_offset: :int64,
                    log_start_offset: :int64,
                    aborted_transactions: {:array, [producer_id: :int64, first_offset: :int64]}
                  ],
                  record_set: :records
                ]}
           ]}
      ]
    end

    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp(deserialize_field(:root, :throttle_time_ms, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :responses, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp(deserialize_field(:responses, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:responses, :partition_responses, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:partition_header, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_header, :error_code, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_header, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_header, :high_watermark, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_header, :high_watermark, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :partition_header,
        :last_stable_offset,
        Map.put(acc, :high_watermark, val),
        rest
      )
    end

    defp(deserialize_field(:partition_header, :last_stable_offset, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :partition_header,
        :log_start_offset,
        Map.put(acc, :last_stable_offset, val),
        rest
      )
    end

    defp(deserialize_field(:partition_header, :log_start_offset, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :partition_header,
        :aborted_transactions,
        Map.put(acc, :log_start_offset, val),
        rest
      )
    end

    defp(deserialize_field(:aborted_transactions, :producer_id, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :aborted_transactions,
        :first_offset,
        Map.put(acc, :producer_id, val),
        rest
      )
    end

    defp(deserialize_field(:aborted_transactions, :first_offset, acc, data)) do
      {val, rest} = deserialize(:int64, data)
      deserialize_field(:aborted_transactions, nil, Map.put(acc, :first_offset, val), rest)
    end

    defp(deserialize_field(:partition_header, :aborted_transactions, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:aborted_transactions, :producer_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :partition_header,
        nil,
        Map.put(acc, :aborted_transactions, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:partition_responses, :partition_header, acc, data)) do
      {val, rest} = deserialize_field(:partition_header, :partition, %{}, data)

      deserialize_field(
        :partition_responses,
        :record_set,
        Map.put(acc, :partition_header, val),
        rest
      )
    end

    defp(deserialize_field(:partition_responses, :record_set, acc, data)) do
      <<msg_set_size::32-signed, msg_set_data::size(msg_set_size)-binary, rest::bits>> = data
      val = Elixir.Kayrock.RecordBatch.deserialize(msg_set_size, msg_set_data)
      deserialize_field(:partition_responses, nil, Map.put(acc, :record_set, val), rest)
    end

    defp(deserialize_field(:responses, :partition_responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_responses, :partition_header, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :responses,
        nil,
        Map.put(acc, :partition_responses, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:responses, :topic, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :responses, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  defmodule(V6.Response) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(throttle_time_ms: nil, responses: [], correlation_id: nil)
    @type t :: %__MODULE__{}
    import(Elixir.Kayrock.Deserialize)

    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      6
    end

    def(schema) do
      [
        throttle_time_ms: :int32,
        responses:
          {:array,
           [
             topic: :string,
             partition_responses:
               {:array,
                [
                  partition_header: [
                    partition: :int32,
                    error_code: :int16,
                    high_watermark: :int64,
                    last_stable_offset: :int64,
                    log_start_offset: :int64,
                    aborted_transactions: {:array, [producer_id: :int64, first_offset: :int64]}
                  ],
                  record_set: :records
                ]}
           ]}
      ]
    end

    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp(deserialize_field(:root, :throttle_time_ms, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :responses, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp(deserialize_field(:responses, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:responses, :partition_responses, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:partition_header, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_header, :error_code, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_header, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_header, :high_watermark, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_header, :high_watermark, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :partition_header,
        :last_stable_offset,
        Map.put(acc, :high_watermark, val),
        rest
      )
    end

    defp(deserialize_field(:partition_header, :last_stable_offset, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :partition_header,
        :log_start_offset,
        Map.put(acc, :last_stable_offset, val),
        rest
      )
    end

    defp(deserialize_field(:partition_header, :log_start_offset, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :partition_header,
        :aborted_transactions,
        Map.put(acc, :log_start_offset, val),
        rest
      )
    end

    defp(deserialize_field(:aborted_transactions, :producer_id, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :aborted_transactions,
        :first_offset,
        Map.put(acc, :producer_id, val),
        rest
      )
    end

    defp(deserialize_field(:aborted_transactions, :first_offset, acc, data)) do
      {val, rest} = deserialize(:int64, data)
      deserialize_field(:aborted_transactions, nil, Map.put(acc, :first_offset, val), rest)
    end

    defp(deserialize_field(:partition_header, :aborted_transactions, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:aborted_transactions, :producer_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :partition_header,
        nil,
        Map.put(acc, :aborted_transactions, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:partition_responses, :partition_header, acc, data)) do
      {val, rest} = deserialize_field(:partition_header, :partition, %{}, data)

      deserialize_field(
        :partition_responses,
        :record_set,
        Map.put(acc, :partition_header, val),
        rest
      )
    end

    defp(deserialize_field(:partition_responses, :record_set, acc, data)) do
      <<msg_set_size::32-signed, msg_set_data::size(msg_set_size)-binary, rest::bits>> = data
      val = Elixir.Kayrock.RecordBatch.deserialize(msg_set_size, msg_set_data)
      deserialize_field(:partition_responses, nil, Map.put(acc, :record_set, val), rest)
    end

    defp(deserialize_field(:responses, :partition_responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_responses, :partition_header, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :responses,
        nil,
        Map.put(acc, :partition_responses, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:responses, :topic, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :responses, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  defmodule(V7.Response) do
    @moduledoc false
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      throttle_time_ms: nil,
      error_code: nil,
      session_id: nil,
      responses: [],
      correlation_id: nil
    )

    @type t :: %__MODULE__{}
    import(Elixir.Kayrock.Deserialize)

    def(api_key) do
      :kpro_schema.api_key(:fetch)
    end

    def(api_vsn) do
      7
    end

    def(schema) do
      [
        throttle_time_ms: :int32,
        error_code: :int16,
        session_id: :int32,
        responses:
          {:array,
           [
             topic: :string,
             partition_responses:
               {:array,
                [
                  partition_header: [
                    partition: :int32,
                    error_code: :int16,
                    high_watermark: :int64,
                    last_stable_offset: :int64,
                    log_start_offset: :int64,
                    aborted_transactions: {:array, [producer_id: :int64, first_offset: :int64]}
                  ],
                  record_set: :records
                ]}
           ]}
      ]
    end

    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp(deserialize_field(:root, :throttle_time_ms, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :error_code, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp(deserialize_field(:root, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:root, :session_id, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:root, :session_id, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :responses, Map.put(acc, :session_id, val), rest)
    end

    defp(deserialize_field(:responses, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:responses, :partition_responses, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:partition_header, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_header, :error_code, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_header, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_header, :high_watermark, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_header, :high_watermark, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :partition_header,
        :last_stable_offset,
        Map.put(acc, :high_watermark, val),
        rest
      )
    end

    defp(deserialize_field(:partition_header, :last_stable_offset, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :partition_header,
        :log_start_offset,
        Map.put(acc, :last_stable_offset, val),
        rest
      )
    end

    defp(deserialize_field(:partition_header, :log_start_offset, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :partition_header,
        :aborted_transactions,
        Map.put(acc, :log_start_offset, val),
        rest
      )
    end

    defp(deserialize_field(:aborted_transactions, :producer_id, acc, data)) do
      {val, rest} = deserialize(:int64, data)

      deserialize_field(
        :aborted_transactions,
        :first_offset,
        Map.put(acc, :producer_id, val),
        rest
      )
    end

    defp(deserialize_field(:aborted_transactions, :first_offset, acc, data)) do
      {val, rest} = deserialize(:int64, data)
      deserialize_field(:aborted_transactions, nil, Map.put(acc, :first_offset, val), rest)
    end

    defp(deserialize_field(:partition_header, :aborted_transactions, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:aborted_transactions, :producer_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :partition_header,
        nil,
        Map.put(acc, :aborted_transactions, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:partition_responses, :partition_header, acc, data)) do
      {val, rest} = deserialize_field(:partition_header, :partition, %{}, data)

      deserialize_field(
        :partition_responses,
        :record_set,
        Map.put(acc, :partition_header, val),
        rest
      )
    end

    defp(deserialize_field(:partition_responses, :record_set, acc, data)) do
      <<msg_set_size::32-signed, msg_set_data::size(msg_set_size)-binary, rest::bits>> = data
      val = Elixir.Kayrock.RecordBatch.deserialize(msg_set_size, msg_set_data)
      deserialize_field(:partition_responses, nil, Map.put(acc, :record_set, val), rest)
    end

    defp(deserialize_field(:responses, :partition_responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_responses, :partition_header, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :responses,
        nil,
        Map.put(acc, :partition_responses, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :responses, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:responses, :topic, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :responses, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  def(deserialize(0, data)) do
    V0.Response.deserialize(data)
  end

  def(deserialize(1, data)) do
    V1.Response.deserialize(data)
  end

  def(deserialize(2, data)) do
    V2.Response.deserialize(data)
  end

  def(deserialize(3, data)) do
    V3.Response.deserialize(data)
  end

  def(deserialize(4, data)) do
    V4.Response.deserialize(data)
  end

  def(deserialize(5, data)) do
    V5.Response.deserialize(data)
  end

  def(deserialize(6, data)) do
    V6.Response.deserialize(data)
  end

  def(deserialize(7, data)) do
    V7.Response.deserialize(data)
  end

  def(min_vsn) do
    0
  end

  def(max_vsn) do
    7
  end
end
