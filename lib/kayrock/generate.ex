defmodule Kayrock.Generate do
  @moduledoc """
  Macros for generating modules for the protocol schema
  """

  require Kayrock.Serialize
  require Kayrock.Deserialize

  def generate_schema_metadata(schema_module) do
    all_apis = schema_module.all_apis()

    version_ranges =
      Enum.map(all_apis, fn api ->
        quote do
          def version_range(unquote(api)), do: unquote(schema_module.vsn_range(api))
        end
      end)

    api_keys =
      List.flatten(
        Enum.map(all_apis, fn api ->
          key = schema_module.api_key(api)

          quote do
            def api_key(unquote(api)), do: unquote(key)
            def api_key(unquote(key)), do: unquote(api)
          end
        end)
      )

    request_schemas =
      List.flatten(
        Enum.map(all_apis, fn api ->
          {min_vsn, max_vsn} = schema_module.vsn_range(api)

          Enum.map(min_vsn..max_vsn, fn vsn ->
            quote do
              def request_schema(unquote(api), unquote(vsn)) do
                unquote(schema_module.req(api, vsn))
              end
            end
          end)
        end)
      )

    response_schemas =
      List.flatten(
        Enum.map(all_apis, fn api ->
          {min_vsn, max_vsn} = schema_module.vsn_range(api)

          Enum.map(min_vsn..max_vsn, fn vsn ->
            quote do
              def response_schema(unquote(api), unquote(vsn)) do
                unquote(schema_module.rsp(api, vsn))
              end
            end
          end)
        end)
      )

    min_known_error_code = -1
    max_known_error_code = 71

    error_codes =
      Enum.map(min_known_error_code..max_known_error_code, fn error_code ->
        error = schema_module.ec(error_code)

        quote do
          def error_code_to_error(unquote(error_code)) do
            unquote(error)
          end
        end
      end)

    quote do
      defmodule Kayrock.KafkaSchemaMetadata do
        @moduledoc false
        _ = "THIS CODE IS GENERATED BY KAYROCK"

        def all_apis do
          unquote(all_apis)
        end

        unquote_splicing(version_ranges)

        unquote_splicing(api_keys)

        unquote_splicing(request_schemas)

        unquote_splicing(response_schemas)

        def min_known_error_code, do: unquote(min_known_error_code)
        def max_known_error_code, do: unquote(max_known_error_code)

        unquote_splicing(error_codes)
      end
    end
  end

  def build_all(api, schema_module) do
    modname = Module.concat([Kayrock, Macro.camelize("#{api}")])
    contents = build_modules(api, schema_module)

    quote do
      defmodule unquote(modname) do
        @moduledoc false
        _ = " THIS CODE IS GENERATED BY KAYROCK"
        unquote_splicing(contents)
      end
    end
  end

  def build_modules(api, schema_module) do
    {vmin, vmax} = schema_module.vsn_range(api)

    List.flatten(
      Enum.map(vmin..vmax, &make_request_module(api, &1, schema_module)) ++
        Enum.map(vmin..vmax, &make_request_getter(&1)) ++
        Enum.map(vmin..vmax, &make_response_module(api, &1, schema_module)) ++
        Enum.map(vmin..vmax, &make_response_deserializer(&1)) ++
        [
          quote do
            def min_vsn, do: unquote(vmin)
          end,
          quote do
            def max_vsn, do: unquote(vmax)
          end
        ]
    )
  end

  def make_request_getter(vsn) do
    quote do
      def get_request_struct(unquote(vsn)) do
        %unquote(modname(vsn, Request)){}
      end
    end
  end

  def make_response_deserializer(vsn) do
    quote do
      def deserialize(unquote(vsn), data) do
        unquote(modname(vsn, Response)).deserialize(data)
      end
    end
  end

  def make_request_module(api, vsn, schema_module) do
    schema = schema_module.req(api, vsn)

    request_module_name = modname(vsn, Request)
    response_module_name = modname(vsn, Response)

    struct = generate_request_struct(api, vsn, request_module_name, response_module_name, schema)
    serializer = generate_serializer(request_module_name)

    List.flatten([struct, serializer])
  end

  def make_response_module(api, vsn, schema_module) do
    schema = schema_module.rsp(api, vsn)

    response_module_name = modname(vsn, Response)

    struct = generate_response_struct(api, vsn, response_module_name, schema)

    List.flatten([struct])
  end

  defp modname(vsn, suffix) do
    Module.concat(["V#{vsn}", suffix])
  end

  def generate_request_struct(api, vsn, modname, response_modname, schema) do
    fields =
      Enum.reduce(schema, [], fn {k, v}, acc ->
        acc ++ [{k, default_val(v)}]
      end) ++ [correlation_id: nil, client_id: nil]

    field_serializers = Enum.map(schema, &field_serializer(&1, :struct))

    # some of the apis don't really have any fields to serialize.  if we don't
    # do this then we end up with an "unused import" warning
    imports =
      if length(fields) > 2 do
        [
          quote do
            import Elixir.Kayrock.Serialize
          end
        ]
      else
        []
      end

    quote do
      defmodule unquote(modname) do
        @moduledoc false
        _ = " THIS CODE IS GENERATED BY KAYROCK"
        defstruct unquote(fields)

        unquote_splicing(imports)

        @type t :: %__MODULE__{}

        def api_key, do: Kayrock.KafkaSchemaMetadata.api_key(unquote(api))

        def api_vsn, do: unquote(vsn)

        def response_deserializer, do: &unquote(response_modname).deserialize/1

        def schema, do: unquote(schema)

        def serialize(%unquote(modname){} = struct) do
          [
            <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
              byte_size(struct.client_id)::16, struct.client_id::binary>>,
            unquote(field_serializers)
          ]
        end
      end
    end
  end

  def generate_response_struct(api, vsn, modname, schema) do
    fields =
      Enum.reduce(schema, [], fn {k, v}, acc ->
        acc ++ [{k, default_val(v)}]
      end) ++ [correlation_id: nil]

    {first_field_name, fields_with_next_field} = build_field_zip(schema)

    field_deserializers =
      List.flatten(
        Enum.map(fields_with_next_field, fn {s, n} -> generate_field_deserializer(:root, s, n) end)
      )

    quote do
      defmodule unquote(modname) do
        @moduledoc false
        _ = " THIS CODE IS GENERATED BY KAYROCK"
        defstruct unquote(fields)

        @type t :: %__MODULE__{}

        import Elixir.Kayrock.Deserialize

        def api_key, do: Kayrock.KafkaSchemaMetadata.api_key(unquote(api))

        def api_vsn, do: unquote(vsn)

        def schema, do: unquote(schema)

        def deserialize(data) do
          <<correlation_id::32-signed, rest::binary>> = data

          deserialize_field(
            :root,
            unquote(first_field_name),
            %__MODULE__{correlation_id: correlation_id},
            rest
          )
        end

        unquote_splicing(field_deserializers)

        defp deserialize_field(_, nil, acc, rest) do
          {acc, rest}
        end
      end
    end
  end

  # we need 'next field' to build the recursive deserializer
  # we also tack on a nil to signify the final field
  defp build_field_zip(schema) do
    field_names = Keyword.keys(schema)
    [first_field_name | rest_of_fields] = field_names
    fields_with_next_field = Enum.zip(schema, rest_of_fields ++ [nil])
    {first_field_name, fields_with_next_field}
  end

  def generate_field_deserializer(scope, {:member_assignment, :bytes}, next_field_name) do
    quote do
      defp deserialize_field(unquote(scope), :member_assignment, acc, data) do
        {val, rest} = Kayrock.MemberAssignment.deserialize(data)

        deserialize_field(
          unquote(scope),
          unquote(next_field_name),
          Map.put(acc, :member_assignment, val),
          rest
        )
      end
    end
  end

  def generate_field_deserializer(scope, {field_name, {:array, type}}, next_field_name)
      when type in Kayrock.Deserialize.primitive_types() do
    quote do
      defp deserialize_field(unquote(scope), unquote(field_name), acc, data) do
        {val, rest} = deserialize_array(unquote(type), data)

        deserialize_field(
          unquote(scope),
          unquote(next_field_name),
          Map.put(acc, unquote(field_name), Enum.reverse(val)),
          rest
        )
      end
    end
  end

  def generate_field_deserializer(scope, {field_name, {:array, elements_schema}}, next_field_name) do
    {first_field_name, fields_with_next_field} = build_field_zip(elements_schema)

    [
      Enum.map(fields_with_next_field, fn {f, n} ->
        generate_field_deserializer(field_name, f, n)
      end),
      quote do
        defp deserialize_field(unquote(scope), unquote(field_name), acc, data) do
          <<num_elements::32-signed, rest::binary>> = data

          {vals, rest} =
            if num_elements > 0 do
              Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
                {val, r} =
                  deserialize_field(unquote(field_name), unquote(first_field_name), %{}, d)

                {[val | acc], r}
              end)
            else
              {[], rest}
            end

          deserialize_field(
            unquote(scope),
            unquote(next_field_name),
            Map.put(acc, unquote(field_name), Enum.reverse(vals)),
            rest
          )
        end
      end
    ]
  end

  def generate_field_deserializer(scope, {field_name, type}, next_field_name)
      when type in Kayrock.Deserialize.primitive_types() do
    quote do
      defp deserialize_field(unquote(scope), unquote(field_name), acc, data) do
        {val, rest} = deserialize(unquote(type), data)

        deserialize_field(
          unquote(scope),
          unquote(next_field_name),
          Map.put(acc, unquote(field_name), val),
          rest
        )
      end
    end
  end

  def generate_field_deserializer(scope, {field_name, :records}, next_field_name) do
    quote do
      defp deserialize_field(unquote(scope), unquote(field_name), acc, data) do
        <<msg_set_size::32-signed, msg_set_data::size(msg_set_size)-binary, rest::bits>> = data

        val = Elixir.Kayrock.RecordBatch.deserialize(msg_set_size, msg_set_data)

        deserialize_field(
          unquote(scope),
          unquote(next_field_name),
          Map.put(acc, unquote(field_name), val),
          rest
        )
      end
    end
  end

  def generate_field_deserializer(scope, {field_name, struct_schema}, next_field_name)
      when is_list(struct_schema) do
    {first_field_name, fields_with_next_field} = build_field_zip(struct_schema)

    [
      Enum.map(fields_with_next_field, fn {f, n} ->
        generate_field_deserializer(field_name, f, n)
      end),
      quote do
        defp deserialize_field(unquote(scope), unquote(field_name), acc, data) do
          {val, rest} =
            deserialize_field(unquote(field_name), unquote(first_field_name), %{}, data)

          deserialize_field(
            unquote(scope),
            unquote(next_field_name),
            Map.put(acc, unquote(field_name), val),
            rest
          )
        end
      end
    ]
  end

  def generate_serializer(modname) do
    quote do
      defimpl Elixir.Kayrock.Request, for: unquote(modname) do
        def serialize(%unquote(modname){} = struct) do
          try do
            unquote(modname).serialize(struct)
          rescue
            e ->
              reraise(Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__)
          end
        end

        def api_vsn(%unquote(modname){}) do
          unquote(modname).api_vsn()
        end

        def response_deserializer(%unquote(modname){}) do
          unquote(modname).response_deserializer()
        end
      end
    end
  end

  ######################################################################
  # SPECIAL CASES
  #

  # protocol metadata for JoinGroup request
  # this is 'bytes' in the spec but it is expected to be the serialization of a
  # ProtocolMetadata message defined in the consumer group API, so we handle
  # both cases here
  defp field_serializer({:protocol_metadata, :bytes}, varname) do
    quote do
      case Map.fetch!(unquote(Macro.var(varname, __MODULE__)), :protocol_metadata) do
        %Kayrock.GroupProtocolMetadata{} = m ->
          Kayrock.Serialize.serialize(
            :iodata_bytes,
            Kayrock.GroupProtocolMetadata.serialize(m)
          )

        b when is_binary(b) ->
          Kayrock.Serialize.serialize(:bytes, b)
      end
    end
  end

  # member assignment for SyncGroup request
  # this is 'bytes' in the spec but it is expected to be the serialization of a
  # MemberAssignment message defined in the consumer group API, so we handle
  # both cases here
  defp field_serializer({:member_assignment, :bytes}, varname) do
    quote do
      case Map.fetch!(unquote(Macro.var(varname, __MODULE__)), :member_assignment) do
        %Kayrock.MemberAssignment{} = m ->
          Kayrock.Serialize.serialize(
            :iodata_bytes,
            Kayrock.MemberAssignment.serialize(m)
          )

        b when is_binary(b) ->
          Kayrock.Serialize.serialize(:bytes, b)
      end
    end
  end

  # END SPECIAL CASES
  ######################################################################

  defp field_serializer({name, type}, varname) when type in Kayrock.Serialize.primitive_types() do
    quote do
      serialize(unquote(type), Map.fetch!(unquote(Macro.var(varname, __MODULE__)), unquote(name)))
    end
  end

  defp field_serializer({name, :records}, varname) do
    quote do
      Elixir.Kayrock.Request.serialize(
        Map.fetch!(unquote(Macro.var(varname, __MODULE__)), unquote(name))
      )
    end
  end

  defp field_serializer({name, {:array, type}}, varname)
       when type in Kayrock.Serialize.primitive_types() do
    quote do
      serialize_array(
        unquote(type),
        Map.fetch!(unquote(Macro.var(varname, __MODULE__)), unquote(name))
      )
    end
  end

  defp field_serializer({name, {:array, el}}, varname) when is_list(el) do
    subfield_serializers = Enum.map(el, &field_serializer(&1, :v))

    quote do
      case Map.fetch!(unquote(Macro.var(varname, __MODULE__)), unquote(name)) do
        nil ->
          <<-1::32-signed>>

        [] ->
          <<0::32-signed>>

        vals when is_list(vals) ->
          [
            <<length(vals)::32-signed>>,
            for v <- vals do
              unquote(subfield_serializers)
            end
          ]
      end
    end
  end

  defp field_serializer({name, {:array, {:array, type}}}, varname)
       when type in Kayrock.Serialize.primitive_types() do
    quote do
      case Map.fetch!(unquote(Macro.var(varname, __MODULE__)), unquote(name)) do
        nil ->
          <<-1::32-signed>>

        [] ->
          <<0::32-signed>>

        vals when is_list(vals) ->
          [
            <<length(vals)::32-signed>>,
            for v <- vals do
              serialize_array(unquote(type), v)
            end
          ]
      end
    end
  end

  defp field_serializer({name, schema}, varname) when is_list(schema) do
    subfield_serializers = Enum.map(schema, &field_serializer(&1, :v))

    quote do
      v = Map.fetch!(unquote(Macro.var(varname, __MODULE__)), unquote(name))
      unquote(subfield_serializers)
    end
  end

  defp default_val({:array, _}), do: []
  defp default_val(_), do: nil
end
