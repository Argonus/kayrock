defmodule Kayrock.Generate do
  @moduledoc """
  Macros for generating modules for the protocol schema
  """

  require Kayrock.Serialize
  require Kayrock.Deserialize

  defmacro __using__(api) do
    build_modules(api)
  end

  def build_all(api) do
    modname = Module.concat([Kayrock, Macro.camelize("#{api}")])
    contents = build_modules(api)

    quote do
      defmodule unquote(modname) do
        @moduledoc false
        _ = " THIS CODE IS GENERATED BY KAYROCK"
        unquote_splicing(contents)
      end
    end
  end

  def build_modules(api) do
    {vmin, vmax} = :kpro_schema.vsn_range(api)

    List.flatten(
      Enum.map(vmin..vmax, &make_request_module(api, &1)) ++
        Enum.map(vmin..vmax, &make_request_getter(&1)) ++
        Enum.map(vmin..vmax, &make_response_module(api, &1)) ++
        Enum.map(vmin..vmax, &make_response_deserializer(&1)) ++
        [
          quote do
            def min_vsn, do: unquote(vmin)
          end,
          quote do
            def max_vsn, do: unquote(vmax)
          end
        ]
    )
  end

  def make_request_getter(vsn) do
    quote do
      def get_request_struct(unquote(vsn)) do
        %unquote(modname(vsn, Request)){}
      end
    end
  end

  def make_response_deserializer(vsn) do
    quote do
      def deserialize(unquote(vsn), data) do
        unquote(modname(vsn, Response)).deserialize(data)
      end
    end
  end

  def make_request_module(api, vsn) do
    schema = :kpro_schema.req(api, vsn)

    request_module_name = modname(vsn, Request)
    response_module_name = modname(vsn, Response)

    struct = generate_request_struct(api, vsn, request_module_name, response_module_name, schema)
    serializer = generate_serializer(request_module_name)

    List.flatten([struct, serializer])
  end

  def make_response_module(api, vsn) do
    schema = :kpro_schema.rsp(api, vsn)

    response_module_name = modname(vsn, Response)

    struct = generate_response_struct(api, vsn, response_module_name, schema)

    List.flatten([struct])
  end

  defp modname(vsn, suffix) do
    Module.concat(["V#{vsn}", suffix])
  end

  def generate_request_struct(api, vsn, modname, response_modname, schema) do
    fields =
      Enum.reduce(schema, [], fn {k, v}, acc ->
        acc ++ [{k, default_val(v)}]
      end) ++ [correlation_id: nil, client_id: nil]

    field_serializers = Enum.map(schema, &field_serializer(&1, :struct))

    # some of the apis don't really have any fields to serialize.  if we don't
    # do this then we end up with an "unused import" warning
    imports =
      if length(fields) > 2 do
        [
          quote do
            import Elixir.Kayrock.Serialize
          end
        ]
      else
        []
      end

    quote location: :keep do
      defmodule unquote(modname) do
        @moduledoc false
        _ = " THIS CODE IS GENERATED BY KAYROCK"
        defstruct unquote(fields)

        unquote_splicing(imports)

        @type t :: %__MODULE__{}

        def api_key, do: :kpro_schema.api_key(unquote(api))

        def api_vsn, do: unquote(vsn)

        def response_deserializer, do: &unquote(response_modname).deserialize/1

        def schema, do: unquote(schema)

        def serialize(%unquote(modname){} = struct) do
          [
            <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
              byte_size(struct.client_id)::16, struct.client_id::binary>>,
            unquote(field_serializers)
          ]
        end
      end
    end
  end

  def generate_response_struct(api, vsn, modname, schema) do
    fields =
      Enum.reduce(schema, [], fn {k, v}, acc ->
        acc ++ [{k, default_val(v)}]
      end) ++ [correlation_id: nil]

    {first_field_name, fields_with_next_field} = build_field_zip(schema)

    field_deserializers =
      List.flatten(
        Enum.map(fields_with_next_field, fn {s, n} -> generate_field_deserializer(:root, s, n) end)
      )

    quote location: :keep do
      defmodule unquote(modname) do
        @moduledoc false
        _ = " THIS CODE IS GENERATED BY KAYROCK"
        defstruct unquote(fields)

        @type t :: %__MODULE__{}

        import Elixir.Kayrock.Deserialize

        def api_key, do: :kpro_schema.api_key(unquote(api))

        def api_vsn, do: unquote(vsn)

        def schema, do: unquote(schema)

        def deserialize(data) do
          <<correlation_id::32-signed, rest::binary>> = data

          deserialize_field(
            :root,
            unquote(first_field_name),
            %__MODULE__{correlation_id: correlation_id},
            rest
          )
        end

        unquote_splicing(field_deserializers)

        defp deserialize_field(_, nil, acc, rest) do
          {acc, rest}
        end
      end
    end
  end

  # we need 'next field' to build the recursive deserializer
  # we also tack on a nil to signify the final field
  defp build_field_zip(schema) do
    field_names = Keyword.keys(schema)
    [first_field_name | rest_of_fields] = field_names
    fields_with_next_field = Enum.zip(schema, rest_of_fields ++ [nil])
    {first_field_name, fields_with_next_field}
  end

  def generate_field_deserializer(scope, {field_name, {:array, type}}, next_field_name)
      when type in Kayrock.Deserialize.primitive_types() do
    quote location: :keep do
      defp deserialize_field(unquote(scope), unquote(field_name), acc, data) do
        {val, rest} = deserialize_array(unquote(type), data)

        deserialize_field(
          unquote(scope),
          unquote(next_field_name),
          Map.put(acc, unquote(field_name), Enum.reverse(val)),
          rest
        )
      end
    end
  end

  def generate_field_deserializer(scope, {field_name, {:array, elements_schema}}, next_field_name) do
    {first_field_name, fields_with_next_field} = build_field_zip(elements_schema)

    [
      Enum.map(fields_with_next_field, fn {f, n} ->
        generate_field_deserializer(field_name, f, n)
      end),
      quote location: :keep do
        defp deserialize_field(unquote(scope), unquote(field_name), acc, data) do
          <<num_elements::32-signed, rest::binary>> = data

          {vals, rest} =
            if num_elements > 0 do
              Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
                {val, r} =
                  deserialize_field(unquote(field_name), unquote(first_field_name), %{}, d)

                {[val | acc], r}
              end)
            else
              {[], rest}
            end

          deserialize_field(
            unquote(scope),
            unquote(next_field_name),
            Map.put(acc, unquote(field_name), Enum.reverse(vals)),
            rest
          )
        end
      end
    ]
  end

  def generate_field_deserializer(scope, {field_name, type}, next_field_name)
      when type in Kayrock.Deserialize.primitive_types() do
    quote location: :keep do
      defp deserialize_field(unquote(scope), unquote(field_name), acc, data) do
        {val, rest} = deserialize(unquote(type), data)

        deserialize_field(
          unquote(scope),
          unquote(next_field_name),
          Map.put(acc, unquote(field_name), val),
          rest
        )
      end
    end
  end

  def generate_field_deserializer(scope, {field_name, :records}, next_field_name) do
    quote location: :keep do
      defp deserialize_field(unquote(scope), unquote(field_name), acc, data) do
        <<msg_set_size::32-signed, msg_set_data::size(msg_set_size)-binary, rest::bits>> = data

        val = Elixir.Kayrock.Message.deserialize_message_set(msg_set_size, msg_set_data)

        deserialize_field(
          unquote(scope),
          unquote(next_field_name),
          Map.put(acc, unquote(field_name), val),
          rest
        )
      end
    end
  end

  def generate_field_deserializer(scope, {field_name, struct_schema}, next_field_name)
      when is_list(struct_schema) do
    {first_field_name, fields_with_next_field} = build_field_zip(struct_schema)

    [
      Enum.map(fields_with_next_field, fn {f, n} ->
        generate_field_deserializer(field_name, f, n)
      end),
      quote location: :keep do
        defp deserialize_field(unquote(scope), unquote(field_name), acc, data) do
          {val, rest} =
            deserialize_field(unquote(field_name), unquote(first_field_name), %{}, data)

          deserialize_field(
            unquote(scope),
            unquote(next_field_name),
            Map.put(acc, unquote(field_name), val),
            rest
          )
        end
      end
    ]
  end

  def generate_serializer(modname) do
    quote location: :keep do
      defimpl Elixir.Kayrock.Request, for: unquote(modname) do
        def serialize(%unquote(modname){} = struct) do
          unquote(modname).serialize(struct)
        end

        def api_vsn(%unquote(modname){}) do
          unquote(modname).api_vsn()
        end

        def response_deserializer(%unquote(modname){}) do
          unquote(modname).response_deserializer()
        end
      end
    end
  end

  defp field_serializer({name, type}, varname) when type in Kayrock.Serialize.primitive_types() do
    quote location: :keep do
      serialize(unquote(type), Map.get(unquote(Macro.var(varname, __MODULE__)), unquote(name)))
    end
  end

  defp field_serializer({name, :records}, varname) do
    quote location: :keep do
      Elixir.Kayrock.Message.serialize(
        Map.get(unquote(Macro.var(varname, __MODULE__)), unquote(name))
      )
    end
  end

  defp field_serializer({name, {:array, type}}, varname)
       when type in Kayrock.Serialize.primitive_types() do
    quote location: :keep do
      serialize_array(
        unquote(type),
        Map.get(unquote(Macro.var(varname, __MODULE__)), unquote(name))
      )
    end
  end

  defp field_serializer({name, {:array, el}}, varname) when is_list(el) do
    subfield_serializers = Enum.map(el, &field_serializer(&1, :v))

    quote location: :keep do
      case Map.get(unquote(Macro.var(varname, __MODULE__)), unquote(name)) do
        nil ->
          <<-1::32-signed>>

        [] ->
          <<0::32-signed>>

        vals when is_list(vals) ->
          [
            <<length(vals)::32-signed>>,
            for v <- vals do
              unquote(subfield_serializers)
            end
          ]
      end
    end
  end

  defp field_serializer({name, {:array, {:array, type}}}, varname)
       when type in Kayrock.Serialize.primitive_types() do
    quote location: :keep do
      case Map.get(unquote(Macro.var(varname, __MODULE__)), unquote(name)) do
        nil ->
          <<-1::32-signed>>

        [] ->
          <<0::32-signed>>

        vals when is_list(vals) ->
          [
            <<length(vals)::32-signed>>,
            for v <- vals do
              serialize_array(unquote(type), v)
            end
          ]
      end
    end
  end

  defp field_serializer({name, schema}, varname) when is_list(schema) do
    subfield_serializers = Enum.map(schema, &field_serializer(&1, :v))

    quote location: :keep do
      v = Map.get(unquote(Macro.var(varname, __MODULE__)), unquote(name))
      unquote(subfield_serializers)
    end
  end

  defp default_val({:array, _}), do: []
  defp default_val(_), do: nil
end
